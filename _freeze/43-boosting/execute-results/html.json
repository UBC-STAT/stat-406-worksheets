{
  "hash": "800eac5cff36a0908178e26c63b48fe4",
  "result": {
    "markdown": "# Boosting (a Statistical Learning perspective)\n\n\n\n\n\n\nIn these notes we will discuss boosting. Our starting point is one its first\nincarnations (the Adaboost.M1 algorithm). Our goal here is two-fold: introduce boosting\nas a **different** way of building an **ensemble** of *weak classifiers*, and \nalso to show how a statistical analysis of the method offers valuable\ninsight and opens a wide range of extensions and new methodologies. \nWe follow the presentation in Chapter 10 of [HTF09]. \n\n## A different kind of ensembles\n\nSo far in this course we have seen ensembles of classifiers \n(or regression estimators) based on the idea of bagging: combininig\nthe predictions of a number of predictors trained on bootstrap \nsamples taken from the original training set. By construction\nall the predictors in the ensemble are treated *equally* (e.g. \ntheir predictions receive the same weight when they are \ncombined). Another characteristic of these ensembles is \nthe predictors in them could be trained in parallel\n(they are independent from each other). \n\nBoosting algorithms go back to the late 90s. One of the first ones\nto appear in the Machine Learning literature is probably *Adaboost.M1*\nintroduced in \n\n> Freund, Y. and Schapire, R. (1997). A decision-theoretic generalization of\n> online learning and an application to boosting, *Journal of Computer\n> and System Sciences*, **55**:119-139.\n\nWe discussed the specifics of the algorithm in class. An important\ndifference with the other ensembles \nwe discussed in class (**can you name them?**)\nis that for *Adaboost.M1* the elements\nof the ensemble are trained **sequentially** in such a way that \nto compute the i-th predictor $T_i$ we need to have the \nprevious one $T_{i-1}$ available. Furthemore, the \nweights in the final combination of predictions are generally\ndifferent for each member of the ensemble. \n\nHere we will use the implementation available in \nthe `adabag` package, specifically the function\n`boosting`. This function can be rather slow, but it\nis a straight implementation of the Adaboost algorithm, \nand it returns many useful objects (e.g. each of the\nindividual weak lerners, etc.) As usual, I suggest that\nyou invest a few minutes reading the help \npages and also *exploring* the returned objects by hand. \n\nNote that Adaboost was originally proposed for 2-class\nproblems. To illustrate its use, we look at the \nzip code digits example. We consider the problem of\nbuilding a classifier to determine whether an image\nis a *1* or a *9*. We use 1-split classification \ntrees as our *weak lerners* in the ensemble.\nSince `boosting` uses the `rpart` implementation\nof classification and regression trees, \nwe use the function `rpart.control` to \nspecify the type of *weak lerners* we want. \n\n\nWe first load the full training set, and extract the \n*7*'s and *9*'s. Since the original data file does\nnot have feature names, we create them as \"V1\", \"V2\", \netc. \n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos1_3ab42edc60a0935f20219f9f33f019a1'}\n\n```{.r .cell-code}\ndata(zip.train, package = \"ElemStatLearn\")\nx.tr <- data.frame(zip.train)\nnames(x.tr) <- paste(\"V\", 1:257, sep = \"\")\nx.tr <- x.tr[x.tr$V1 %in% c(1, 9), ]\n```\n:::\n\nTo force `rpart` (and thus `boosting`)\nto train a classification ensemble (as opposed to a \nregression one) we force the response variable to \nbe categorical. \n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos1.factor_5812105ee697b316ee6bdd3586d2545a'}\n\n```{.r .cell-code}\nx.tr$V1 <- as.factor(x.tr$V1)\n```\n:::\n\nNow we load the `adabag` package, use `rpart.control` to force\nit to use 1- or 2-split trees, and train the boosting ensemble:\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos1.train_21ad8c39062554e61916d431b98e5fcd'}\n\n```{.r .cell-code}\nlibrary(adabag)\nonesplit <- rpart.control(cp = -1, maxdepth = 1, minsplit = 0, xval = 0)\nbo1 <- boosting(V1 ~ ., data = x.tr, boos = FALSE, mfinal = 500, control = onesplit)\n```\n:::\n\n\nWe can explore the evolution of the error rate on the training set\n(the equivalent of the MSE for classifiers) using the function\n`errorevol`:\n\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos1.plot_e1635f8122b206d55f076eb8b46d66b7'}\n\n```{.r .cell-code}\nplot(errorevol(bo1, newdata = x.tr))\n```\n\n::: {.cell-output-display}\n![](43-boosting_files/figure-html/boos1.plot-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nNote that after approximately 10 iterations the error rate on the\ntraining set drops to zero and stays there. A few questions for you:\n\n* Has the algorithm converged after approximately 10 iterations? \n* Are the predictors trained after the (approximately) 10th iteration irrelevant? \n\nAs we know pretty well by now, a more reliable measure of \nthe expected performance of the ensemble can be obtained \nusing a test set (or cross-validation) (**what about OOB?**)\n\nFirst load the full test set, extract the cases corresponding\nto the digits we are using here, and check the performance\nof the predictor, including the plot of the error rate \nas a function of the number of elements in the ensemble:\n\n\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos2_da8104da533f687bf663a35565cce57c'}\n\n```{.r .cell-code}\ndata(zip.test, package = \"ElemStatLearn\")\nx.te <- data.frame(zip.test)\nnames(x.te) <- paste(\"V\", 1:257, sep = \"\")\nx.te <- x.te[x.te$V1 %in% c(1, 9), ]\nx.te$V1 <- as.factor(x.te$V1)\ntable(x.te$V1, predict(bo1, newdata = x.te)$class)\n#>    \n#>       1   9\n#>   1 260   4\n#>   9   1 176\nplot(errorevol(bo1, newdata = x.te))\n```\n\n::: {.cell-output-display}\n![](43-boosting_files/figure-html/boos2-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nJust to make sure boosting is doing a good job, we \ncompare it with another ensemble classifier: a Random Forest. \nWe use the same number of elements in both ensembles \n(500), even though their complexity is \nvery different -- while boosting used *stumps* (1-split \ntrees), the *random forest trees* are (purposedly)\nvery large (deep). \n\nWe first train the random forest\nand look at the error rates \nas displayed by the `plot` method for\nobjects of class `randomForest`:\n\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos.comp_46f4b30071a20267a01c37423e0493a9'}\n\n```{.r .cell-code}\nset.seed(987)\nlibrary(randomForest)\na <- randomForest(V1 ~ ., data = x.tr) # , ntree=500)\nplot(a)\n```\n\n::: {.cell-output-display}\n![](43-boosting_files/figure-html/boos.comp-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nNow we evaluate the performance of the Random Forest on the\ntraining set by obtaining *fitted values* (\"predictions\" for the \nobservations in the training set) and looking at the \ncorresponding \"confusion table\": \n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos.comp2_fa23186429340c3f749ee432bc616b0d'}\n\n```{.r .cell-code}\ntable(x.tr$V1, predict(a, newdata = x.tr, type = \"response\"))\n#>    \n#>        1    9\n#>   1 1005    0\n#>   9    0  644\n```\n:::\n\nAn interesting question to ask yourself at this point is: **Does this \n\"confusion table\" match the information from the error plot above?** \nCan you describe (and explain!) the apparent problem?\n\nAs we all know too well, of course, the classification error rate *on the test set* \nis a better measure of predicition performance:\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos.comp3_445cab64c119ed0b7a53ba42dbc6f31e'}\n\n```{.r .cell-code}\npr.rf <- predict(a, newdata = x.te, type = \"response\")\ntable(x.te$V1, pr.rf)\n#>    pr.rf\n#>       1   9\n#>   1 259   5\n#>   9   2 175\n```\n:::\n\nWe see that in this case the random forest does marginally worse\nthan the boosting ensemble, even though the  ensemble elements \nusing in boosting are extremely simple trees. \n\n### Another example\n\n\nConsider the ISOLET data introduced earlier. Here we will consider\nbuilding a classifier to discriminate between the letters *A* and *H*\nbased on the features extracted from their sound recordings. \nThe steps of the analysis are the same as before: \n\nFirst we load the training set\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos4_f713b4a2b7ede85a4ed7eb63a09ca9f3'}\n\n```{.r .cell-code}\nxtr <- read.table(\"data/isolet-train-a-h.data\", sep = \",\", header = TRUE)\n```\n:::\n\nNext, we force the response to be a categorical variable:\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos4.2_24ab5f05b56952b57e95197ee9c1025e'}\n\n```{.r .cell-code}\nxtr$V618 <- as.factor(xtr$V618)\n```\n:::\n\nNow train a boosting ensamble and evaluate it on the test set\n(which needs to be loaded as well):\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos4.3_3942bb6243be1581721434696d64c1a6'}\n\n```{.r .cell-code}\nonesplit <- rpart.control(cp = -1, maxdepth = 1, minsplit = 0, xval = 0)\nbo1 <- boosting(V618 ~ ., data = xtr, boos = FALSE, mfinal = 200, control = onesplit)\nxte <- read.table(\"data/isolet-test-a-h.data\", sep = \",\", header = TRUE)\nxte$V618 <- as.factor(xte$V618)\ntable(xte$V618, predict(bo1, newdata = xte)$class)\n#>    \n#>      1  8\n#>   1 59  1\n#>   8  0 60\n```\n:::\n\nWe can also look at the error evolution on the test set to decide whether\na smaller ensemble would be satisfactory:\n\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos4.4_c842f8f58dd76b7a8545702744fbd231'}\n\n```{.r .cell-code}\nplot(errorevol(bo1, newdata = xte))\n```\n\n::: {.cell-output-display}\n![](43-boosting_files/figure-html/boos4.4-1.png){fig-align='center' width=90%}\n:::\n:::\n\n\nFinally, we compare these results with those obtained with a Random Forest:\n\n\n::: {.cell layout-align=\"center\" hash='43-boosting_cache/html/boos4.5_4bd524561cfaf2f33f2e6a5008924849'}\n\n```{.r .cell-code}\nset.seed(123)\na.rf <- randomForest(V618 ~ ., data = xtr, ntree = 200)\nplot(a.rf)\n```\n\n::: {.cell-output-display}\n![](43-boosting_files/figure-html/boos4.5-1.png){fig-align='center' width=90%}\n:::\n\n```{.r .cell-code}\np.rf <- predict(a.rf, newdata = xte, type = \"response\")\ntable(xte$V618, p.rf)\n#>    p.rf\n#>      1  8\n#>   1 58  2\n#>   8  0 60\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}