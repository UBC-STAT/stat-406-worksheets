<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>7 Non-parametric regression | UBC Stat 406 Worksheets</title>
<meta name="author" content="Daniel J. McDonald and Matías Salibán-Barrera">
<meta name="description" content="We now turn our attention to the situation where the regression function E(Y|X) is not necessarily linear. Furthermore, we will assume that its form is unknown. If we knew that the regression...">
<meta name="generator" content="bookdown 0.23 with bs4_book()">
<meta property="og:title" content="7 Non-parametric regression | UBC Stat 406 Worksheets">
<meta property="og:type" content="book">
<meta property="og:url" content="https://ubc-stat.github.io/stat-406-worksheets/non-parametric-regression.html">
<meta property="og:description" content="We now turn our attention to the situation where the regression function E(Y|X) is not necessarily linear. Furthermore, we will assume that its form is unknown. If we knew that the regression...">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7 Non-parametric regression | UBC Stat 406 Worksheets">
<meta name="twitter:description" content="We now turn our attention to the situation where the regression function E(Y|X) is not necessarily linear. Furthermore, we will assume that its form is unknown. If we knew that the regression...">
<!-- JS --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://kit.fontawesome.com/6ecbd6c532.js" crossorigin="anonymous"></script><script src="libs/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="libs/bootstrap-4.6.0/bootstrap.min.css" rel="stylesheet">
<script src="libs/bootstrap-4.6.0/bootstrap.bundle.min.js"></script><script src="libs/bs3compat-0.2.5.1/tabs.js"></script><script src="libs/bs3compat-0.2.5.1/bs3compat.js"></script><link href="libs/bs4_book-1.0.0/bs4_book.css" rel="stylesheet">
<script src="libs/bs4_book-1.0.0/bs4_book.js"></script><script src="libs/accessible-code-block-0.0.1/empty-anchor.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- CSS -->
</head>
<body data-spy="scroll" data-target="#toc">

<div class="container-fluid">
<div class="row">
  <header class="col-sm-12 col-lg-3 sidebar sidebar-book"><a class="sr-only sr-only-focusable" href="#content">Skip to main content</a>

    <div class="d-flex align-items-start justify-content-between">
      <h1>
        <a href="index.html" title="">UBC Stat 406 Worksheets</a>
      </h1>
      <button class="btn btn-outline-primary d-lg-none ml-2 mt-1" type="button" data-toggle="collapse" data-target="#main-nav" aria-expanded="true" aria-controls="main-nav"><i class="fas fa-bars"></i><span class="sr-only">Show table of contents</span></button>
    </div>

    <div id="main-nav" class="collapse-lg">
      <form role="search">
        <input id="search" class="form-control" type="search" placeholder="Search" aria-label="Search">
</form>

      <nav aria-label="Table of contents"><h2>Table of contents</h2>
        <ul class="book-toc list-unstyled">
<li><a class="" href="index.html">Stat 406 Worksheets</a></li>
<li><a class="" href="preface.html">Preface</a></li>
<li class="book-part">Module 0 – Review</li>
<li><a class="" href="predictions-using-a-linear-model.html"><span class="header-section-number">1</span> Predictions using a linear model</a></li>
<li class="book-part">Module 1 – Model Selection</li>
<li><a class="" href="predictions-using-a-linear-model-continued.html"><span class="header-section-number">2</span> Predictions using a linear model (continued)</a></li>
<li><a class="" href="cross-validation-concerns.html"><span class="header-section-number">3</span> Cross-validation concerns</a></li>
<li><a class="" href="comparing-models.html"><span class="header-section-number">4</span> Comparing models</a></li>
<li class="book-part">Module 2 – Regression</li>
<li><a class="" href="ridge-regression.html"><span class="header-section-number">5</span> Ridge regression</a></li>
<li><a class="" href="lasso.html"><span class="header-section-number">6</span> LASSO</a></li>
<li><a class="active" href="non-parametric-regression.html"><span class="header-section-number">7</span> Non-parametric regression</a></li>
<li><a class="" href="kernel-regression-local-regression.html"><span class="header-section-number">8</span> Kernel regression / local regression</a></li>
<li><a class="" href="regression-trees.html"><span class="header-section-number">9</span> Regression trees</a></li>
<li><a class="" href="pruning-regression-trees-with-rpart.html"><span class="header-section-number">10</span> Pruning regression trees with rpart</a></li>
<li class="book-part">Module 3 – Classification</li>
<li><a class="" href="parametric-classifiers.html"><span class="header-section-number">11</span> Parametric classifiers</a></li>
<li><a class="" href="qda.html"><span class="header-section-number">12</span> QDA</a></li>
<li><a class="" href="classification-trees.html"><span class="header-section-number">13</span> Classification Trees</a></li>
<li><a class="" href="bagging-for-regression.html"><span class="header-section-number">14</span> Bagging for regression</a></li>
<li><a class="" href="bagging-for-classification.html"><span class="header-section-number">15</span> Bagging for classification</a></li>
<li><a class="" href="random-forests.html"><span class="header-section-number">16</span> Random Forests</a></li>
<li><a class="" href="boosting-a-statistical-learning-perspective.html"><span class="header-section-number">17</span> Boosting (a Statistical Learning perspective)</a></li>
<li><a class="" href="what-is-adaboost-doing-really.html"><span class="header-section-number">18</span> What is Adaboost doing, really?</a></li>
<li><a class="" href="single-layer-neural-network.html"><span class="header-section-number">19</span> Single layer neural network</a></li>
<li class="book-part">Module 5 – Unsupervised learning</li>
<li><a class="" href="introduction.html"><span class="header-section-number">20</span> Introduction</a></li>
<li><a class="" href="clustering.html"><span class="header-section-number">21</span> Clustering</a></li>
<li><a class="" href="model-based-clustering.html"><span class="header-section-number">22</span> Model based clustering</a></li>
<li><a class="" href="hierarchical-clustering.html"><span class="header-section-number">23</span> Hierarchical clustering</a></li>
<li><a class="" href="references.html">References</a></li>
<li class="book-part">Appendix</li>
<li><a class="" href="alt-pca.html"><span class="header-section-number">A</span> PCA and alternating regression</a></li>
</ul>

        <div class="book-extra">
          <p><a id="book-repo" href="https://github.com/ubc-stat/stat-406-worksheets">View book source <i class="fab fa-github"></i></a></p>
        </div>
      </nav>
</div>
  </header><main class="col-sm-12 col-md-9 col-lg-7" id="content"><div id="non-parametric-regression" class="section level1">
<h1>
<span class="header-section-number">7</span> Non-parametric regression<a class="anchor" aria-label="anchor" href="#non-parametric-regression"><i class="fas fa-link"></i></a>
</h1>
<p>We now turn our attention to the situation where the
regression function E(Y|X) is not necessarily linear.
Furthermore, we will assume that its <em>form</em> is
<strong>unknown</strong>. If we knew that the regression
function was a linear combination
of a sine and a cosine function, “E(Y|X=x) = a + b sin(x)
+ c cos(x)”, where <em>a</em>, <em>b</em> and <em>c</em> are uknown,
for example, then the problem would in fact be a linear
regression problem. More in general,
when the true regression function is known (or
assumed) to belong to a family of functions that we can parametrize, then
the estimation can be done via standard least squares.
Instead here we focus on the case where the
regression function is <strong>completely unknown</strong>.</p>
<p>In this note and the next one will discuss two ways to estimating
<span class="math inline">\(E(Y|X)\)</span>:</p>
<ol style="list-style-type: lower-alpha">
<li>one using bases (e.g. a polynomial basis, or a spline basis); and</li>
<li>one using kernels (aka local regression).</li>
</ol>
<p>To simplify the presentation (but also because of
an intrinsic limitation of these methods, which will
be discussed in more detail later in the course), we will initially only consider
the case where there is a single explanatory variable
(i.e. X above is a scalar, not a vector).</p>
<div id="polynomial-regression" class="section level2">
<h2>
<span class="header-section-number">7.1</span> Polynomial regression<a class="anchor" aria-label="anchor" href="#polynomial-regression"><i class="fas fa-link"></i></a>
</h2>
<p>To illustrate these basis methods, we will consider the
<code>lidar</code> data, available in the package <code>SemiPar</code>. More
information is available from the
corresponding help page: <code><a href="https://rdrr.io/pkg/SemiPar/man/lidar.html">help(lidar, package='SemiPar')</a></code>.
We now load the data and plot it, the response
variable is <code>logratio</code> and the explanatory one is
<code>range</code>:</p>
<div class="sourceCode" id="cb72"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/utils/data.html">data</a></span><span class="op">(</span><span class="va">lidar</span>, package <span class="op">=</span> <span class="st">"SemiPar"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/nonparam-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>In class we discussed the formal motivation to look into
a polynomial approximation of the regression function.
This argument, however, does not specify which degree
of the approximating polynomial to use. Here we
first try a 4th degree polynomial and the problem reduces to a linear
regression one (see the lecture slides). We can use a
command like <code><a href="https://rdrr.io/r/stats/lm.html">lm(logratio ~ range + range^2 + range^3 + range^4)</a></code>.
However, this call to <code>lm</code> will not work as we intend it
(I recommend that you check this and find out the reason why).
Instead, we would need to use something like
<code><a href="https://rdrr.io/r/stats/lm.html">lm(logratio ~ range + I(range^2) + I(range^3) + I(range^4))</a></code>.
To avoid having to type a long formula, we can instead use
the function <code><a href="https://rdrr.io/r/stats/poly.html">poly()</a></code> in <code>R</code> to generate the design matrix
containing the desired powers
of <code>range</code>, and plug that into the call to <code><a href="https://rdrr.io/r/stats/lm.html">lm()</a></code>.
The code below fits two such approximations (a 3rd degree and a
4th degree polynomial), plots the data
and overlays the estimated regression function:</p>
<div class="sourceCode" id="cb73"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Degree 4 polynomials</span>
<span class="va">pm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/poly.html">poly</a></span><span class="op">(</span><span class="va">range</span>, <span class="fl">4</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">pm</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>
<span class="va">pm3</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/poly.html">poly</a></span><span class="op">(</span><span class="va">range</span>, <span class="fl">3</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">pm3</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"hotpink"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/legend.html">legend</a></span><span class="op">(</span><span class="st">"topright"</span>, legend <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"3rd degree"</span>, <span class="st">"4th degree"</span><span class="op">)</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="st">"hotpink"</span>, <span class="st">"blue"</span><span class="op">)</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/poly4-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>Note that this fit is reasonable, although there is probably
room for improvement. Based on the
formal motivation discussed in class to use polynomials in the first
place, it may seem natural to increase the order
of the approximating polynomial in order to improve the quality
of the approximation. However, this is
easily seen not to be a good idea. Below we compare the
4th degree approximation used above (in blue) with
a 10th degree one (in red):</p>
<div class="sourceCode" id="cb74"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Degree 10 polynomials</span>
<span class="va">pm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/stats/poly.html">poly</a></span><span class="op">(</span><span class="va">range</span>, <span class="fl">10</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">pm</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">pm2</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/poly10-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>Note that the 10th order fit follows the data much more closely, but
it starts to become “too adaptive” and departing quite often from the
main (larger scale) trend we associate with the regression (conditional
mean) function.</p>
<p>(Can you explain the discrepancy between what we observe above and
the motivation we used in class, that suggests that higher order
polynomials provide better approximations?)</p>
</div>
<div id="a-more-stable-basis-splines" class="section level2">
<h2>
<span class="header-section-number">7.2</span> A more stable basis: splines<a class="anchor" aria-label="anchor" href="#a-more-stable-basis-splines"><i class="fas fa-link"></i></a>
</h2>
<p>Part of the problem with global polynomial bases as the ones used
above is that they necessarily become more wiggly within the range of the data, and also quickly
increase or decrease near the edge of the observations. A more stable
but also remarkably flexible basis is given by spline functions,
as discussed in class.</p>
<p>We first here show how to build a naive linear spline basis with
5 knots (placed at the <code>(1:5)/6</code> quantiles
(i.e. the 0.17, 0.33, 0.5, 0.67, 0.83 percentiles) of the
observed values of the explanatory variable), and use
it to estimate the regression function.
Remember that a linear spline function with knot <em>w</em> is
given by <code>f_w(x) = max( x - w, 0 )</code>. Given a fixed
set of pre-selected knots <em>w_1</em>, <em>w_2</em>, …, <em>w_k</em>,
we consider regression functions that are linear combinations
of the corresponding k linear spline functions.</p>
<p>Note that for higher-order splines (e.g. cubic splines
discussed below), the naive spline basis used above is numerically
very unstable, and usually works poorly in practice.
I include it here simply as an illustration of the
methodology and to stress the point that this type of approach
(that estimates the regression function as a linear combination
of an explicit basis) is in fact nothing
more than slightly more complex linear models.</p>
<p>First we find the 5 knots mentioned above that will be used to
construct the spline basis:</p>
<div class="sourceCode" id="cb75"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># select the knots at 5 specific quantiles</span>
<span class="op">(</span><span class="va">kn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="fl">5</span><span class="op">)</span> <span class="op">/</span> <span class="fl">6</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] 444.6667 499.6667 555.0000 609.6667 664.6667</span></code></pre></div>
<p>Now we compute the matrix of “explanatory variables”, that
is: the matrix that in its columns has each of the 5 basis
functions <em>f_1</em>, <em>f_2</em>, …, <em>f_5</em> evaluated
at the n observed values of the (single) explanatory variable <em>x_1</em>, …, <em>x_n</em>. In other words, the
matrix <strong>X</strong> has in its <em>(i, j)</em> cell the value <em>f_j(x_i)</em>,
for <em>j=1</em>, …, <em>k</em>, and <em>i=1</em>, …, <em>n</em>. In the code below we use (abuse?) <code>R</code>’s <em>recycling</em> rules
when operating over vectors and arrays (can you spot it?)</p>
<div class="sourceCode" id="cb76"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># prepare the matrix of covariates / explanatory variables</span>
<span class="va">x</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/matrix.html">matrix</a></span><span class="op">(</span><span class="fl">0</span>, <span class="fu"><a href="https://rdrr.io/r/base/dim.html">dim</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">)</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">kn</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span>
<span class="kw">for</span> <span class="op">(</span><span class="va">j</span> <span class="kw">in</span> <span class="fl">1</span><span class="op">:</span><span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">kn</span><span class="op">)</span><span class="op">)</span> <span class="op">{</span>
    <span class="va">x</span><span class="op">[</span>, <span class="va">j</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">pmax</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span> <span class="op">-</span> <span class="va">kn</span><span class="op">[</span><span class="va">j</span><span class="op">]</span>, <span class="fl">0</span><span class="op">)</span>
<span class="op">}</span>
<span class="va">x</span><span class="op">[</span>, <span class="fu"><a href="https://rdrr.io/r/base/length.html">length</a></span><span class="op">(</span><span class="va">kn</span><span class="op">)</span> <span class="op">+</span> <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;-</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span></code></pre></div>
<p>Now that we have the matrix of our “explanatory variables”, we can simply use <code>lm</code> to estimate
the coefficients of the linear combination of the functions in the spline basis
that will provide our regression function estimator. We then plot the data and overlay the
fitted / estimated regression function:</p>
<div class="sourceCode" id="cb77"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># Fit the regression model</span>
<span class="va">ppm</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">x</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppm</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"hotpink"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/splines1-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>There are better (numerically more stable) bases for the same linear
space spanned by these spline functions. These bases have different
numerical properties and can become cumbersome to describe. Here we
use the function <code>bs</code> (in package <code>splines</code>) to build a B-spline basis.
For an accessible discussion, see for example <span class="citation">(Wood <a href="references.html#ref-wood2017generalized" role="doc-biblioref">2017</a>, Section 4.1)</span>.</p>
<p>Given the chosen knots and the degree of the splines
(linear, quadratic, cubic, etc.) the set (linear space)
of functions we are using to construct our regression estimate
does not depend on the specific basis we use
(in other words: these are different bases that span
the same linear space of functions). As a consequence,
the estimated regression function should be the same regardless of the basis we use
(provided we do not run into serious numerical issues
with our naive basis). To illustrate this fact,
we will use a B-spline basis with the same 5 knots as above,
and compare the estimated regression
function with the one we obtained above
using our <strong>poor people naive basis</strong>. The plot below overlays both
fits (the naive one with a thick pink line as above, and the one
using b-splines with a thinner blue line):</p>
<div class="sourceCode" id="cb78"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="kw"><a href="https://rdrr.io/r/base/library.html">library</a></span><span class="op">(</span><span class="va">splines</span><span class="op">)</span>
<span class="va">ppm2</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">1</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppm</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">8</span>, col <span class="op">=</span> <span class="st">"hotpink"</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppm2</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">3</span>, col <span class="op">=</span> <span class="st">"darkblue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines1-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>As expected, both fits provide the same estimated regression function, although
its coefficients are naturally different (<strong>but their lengths are the same</strong>,
is this a coincidence, or will it always happen?)</p>
<div class="sourceCode" id="cb79"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">ppm</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1]  0.0269095640  0.0002488169 -0.0003235802 -0.0082773735  0.0063779378</span>
<span class="co">#&gt; [6]  0.0007385513 -0.0001847752</span>
<span class="fu"><a href="https://rdrr.io/r/base/vector.html">as.vector</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/coef.html">coef</a></span><span class="op">(</span><span class="va">ppm2</span><span class="op">)</span><span class="op">)</span>
<span class="co">#&gt; [1] -0.04515276 -0.01010104 -0.00657875 -0.02093988 -0.48762440 -0.60636798</span>
<span class="co">#&gt; [7] -0.68496471</span></code></pre></div>
<p>Note that, because we are
using a set of linear splines, our estimated regression functions will always be piecewise
linear (i.e. linear functions between each pair of knots). To obtain smoother (e.g. differentiable,
continuously differentiable, or even twice continously differentiable)
regression estimators below we will use higher-order splines.</p>
</div>
<div id="higher-order-splines-quadratic-cubic-etc." class="section level2">
<h2>
<span class="header-section-number">7.3</span> Higher order splines (quadratic, cubic, etc.)<a class="anchor" aria-label="anchor" href="#higher-order-splines-quadratic-cubic-etc."><i class="fas fa-link"></i></a>
</h2>
<p>In what follows (as above) we will use the function <code>bs</code> to evaluate the desired
spline basis on the observed values of the explanatory variable (in this case <code>range</code>).</p>
<p>We use the arguments <code>degree = 2</code> and <code>knots = kn</code> to indicate we want a
quadratic spline basis with knots located at the elements of the vector <code>kn</code>.
As before, we then simply use <code>lm</code>
to estimate the coefficients, and overlay the estimated regression
function over the data:</p>
<div class="sourceCode" id="cb80"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">ppmq</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">2</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmq</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"steelblue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines2-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>A useful consequence of the fact that these regression estimators are in fact
just linear regression estimators
(but using a richer / more flexible basis than just the straight
predictors) is that we can easily compute (pointwise) standard errors
for the fitted regression curve, as follows. We first fit and
plot a quadratic
spline using the same 5 knots as before:</p>
<div class="sourceCode" id="cb81"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">ppmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">2</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"gray30"</span><span class="op">)</span></code></pre></div>
<p>To compute the estimated standard error of the predicted regression curve on a grid
of values of the explanatory variable <code>range</code>, we first build a grid of 200 equally spaced points
within the observed scope of the variable <code>range</code>:</p>
<div class="sourceCode" id="cb82"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">xx</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/seq.html">seq</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">min</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/Extremes.html">max</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span><span class="op">)</span>, length <span class="op">=</span> <span class="fl">200</span><span class="op">)</span></code></pre></div>
<p>The <code>predict</code> method for objects of class <code>lm</code> returns estimated standard
errors for each fitted value if we set the argument
<code>se.fit = TRUE</code>:</p>
<div class="sourceCode" id="cb83"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">ppmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">2</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="va">ps</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span>, newdata <span class="op">=</span> <span class="fu"><a href="https://rdrr.io/r/base/list.html">list</a></span><span class="op">(</span>range <span class="op">=</span> <span class="va">xx</span><span class="op">)</span>, se.fit <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span></code></pre></div>
<p>We now compute upper and lower confidence bands (I used 2 standard errors) around the fitted regression line:</p>
<div class="sourceCode" id="cb84"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">up</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">ps</span><span class="op">$</span><span class="va">fit</span> <span class="op">+</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">ps</span><span class="op">$</span><span class="va">se.fit</span><span class="op">)</span>
<span class="va">lo</span> <span class="op">&lt;-</span> <span class="op">(</span><span class="va">ps</span><span class="op">$</span><span class="va">fit</span> <span class="op">-</span> <span class="fl">2</span> <span class="op">*</span> <span class="va">ps</span><span class="op">$</span><span class="va">se.fit</span><span class="op">)</span></code></pre></div>
<p>Finally, we display the <em>confidence bands</em> we just constructed (using <strong>base R</strong> graphics,
but also consider using <code>ggplot2</code>):</p>
<div class="sourceCode" id="cb85"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">4</span>, col <span class="op">=</span> <span class="st">"gray30"</span><span class="op">)</span>
<span class="va">myrgb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/col2rgb.html">col2rgb</a></span><span class="op">(</span><span class="st">"red"</span><span class="op">)</span> <span class="op">/</span> <span class="fl">256</span> <span class="co"># , alpha=TRUE)</span>
<span class="va">myrgb</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/grDevices/rgb.html">rgb</a></span><span class="op">(</span>red <span class="op">=</span> <span class="va">myrgb</span><span class="op">[</span><span class="fl">1</span><span class="op">]</span>, green <span class="op">=</span> <span class="va">myrgb</span><span class="op">[</span><span class="fl">2</span><span class="op">]</span>, blue <span class="op">=</span> <span class="va">myrgb</span><span class="op">[</span><span class="fl">3</span><span class="op">]</span>, alpha <span class="op">=</span> <span class="fl">.3</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/polygon.html">polygon</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">xx</span>, <span class="fu"><a href="https://rdrr.io/r/base/rev.html">rev</a></span><span class="op">(</span><span class="va">xx</span><span class="op">)</span><span class="op">)</span>, <span class="fu"><a href="https://rdrr.io/r/base/c.html">c</a></span><span class="op">(</span><span class="va">up</span>, <span class="fu"><a href="https://rdrr.io/r/base/rev.html">rev</a></span><span class="op">(</span><span class="va">lo</span><span class="op">)</span><span class="op">)</span>, density <span class="op">=</span> <span class="cn">NA</span>, col <span class="op">=</span> <span class="va">myrgb</span><span class="op">)</span> <span class="co">#' lightblue')</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">ps</span><span class="op">$</span><span class="va">fit</span> <span class="op">~</span> <span class="va">xx</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">4</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines.se5-1.png" width="90%" style="display: block; margin: auto;"></div>
<p><strong>It is important to note that the above confidence bands were constructed assuming that the knots were fixed (not random), and similarly for the degree of the spline basis.</strong></p>
<p>Increasing the degree of the cubic basis yields smoother fits (having higher order continuous derivatives). For example, using cubic splines yields an even smoother fit:</p>
<div class="sourceCode" id="cb86"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="co"># cubic splines</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">ppmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">3</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"tomato3"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines3-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>Note that the estimated regression function seems to have started to “twitch”
and wiggle, particularly at the upper end of our observations.</p>
</div>
<div id="how-many-knots-should-we-use" class="section level2">
<h2>
<span class="header-section-number">7.4</span> How many knots should we use?<a class="anchor" aria-label="anchor" href="#how-many-knots-should-we-use"><i class="fas fa-link"></i></a>
</h2>
<p>So far we have used 5 knots, but we could have used any other number of knots. If we consider a quadratic
spline basis with 10 knots, the fit appears a bit better (at least aesthetically):</p>
<div class="sourceCode" id="cb87"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">k</span> <span class="op">&lt;-</span> <span class="fl">10</span>
<span class="va">kn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">k</span><span class="op">)</span><span class="op">/</span><span class="op">(</span><span class="va">k</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">ppmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">2</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"tomato3"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines.10knots-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>What about using more knots? The following plot used 50 knots:</p>
<div class="sourceCode" id="cb88"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">k</span> <span class="op">&lt;-</span> <span class="fl">50</span>
<span class="va">kn</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/base/numeric.html">as.numeric</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/quantile.html">quantile</a></span><span class="op">(</span><span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, <span class="op">(</span><span class="fl">1</span><span class="op">:</span><span class="va">k</span><span class="op">)</span> <span class="op">/</span> <span class="op">(</span><span class="va">k</span> <span class="op">+</span> <span class="fl">1</span><span class="op">)</span><span class="op">)</span><span class="op">)</span>
<span class="va">ppmc</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/lm.html">lm</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/splines/bs.html">bs</a></span><span class="op">(</span><span class="va">range</span>, degree <span class="op">=</span> <span class="fl">2</span>, knots <span class="op">=</span> <span class="va">kn</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="fu"><a href="https://rdrr.io/r/stats/predict.html">predict</a></span><span class="op">(</span><span class="va">ppmc</span><span class="op">)</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/order.html">order</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span><span class="op">]</span> <span class="op">~</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html">sort</a></span><span class="op">(</span><span class="va">range</span><span class="op">)</span>, data <span class="op">=</span> <span class="va">lidar</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"hotpink"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/bsplines.50knots-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>Clearly not a good idea!</p>
</div>
<div id="smoothing-splines" class="section level2">
<h2>
<span class="header-section-number">7.5</span> Smoothing splines<a class="anchor" aria-label="anchor" href="#smoothing-splines"><i class="fas fa-link"></i></a>
</h2>
<p>If we were to follow the approach discussed so far we would need to
find an “optimal” of selecting the number of knots and their
positions, <strong>plus</strong> the order of the spline basis. Although one
could consider using cross-validation for this, we note that
this would require considerable computational effort (we would need
to perform an exhaustive search on a 3-dimensional grid).</p>
<p>We saw in class that <em>natural cubic splines</em> provide a natural
<em>optimal</em>
space to look for a good regression estimator. For a formal
but surprisingly simple proof of this optimality result,
see again Section 4.1 of</p>
<blockquote>
<p>Wood, S. (2006). <em>Generalized additive models : an introduction with R</em>.
Chapman &amp; Hall/CRC,
Boca Raton, FL. <a href="http://resolve.library.ubc.ca/cgi-bin/catsearch?bid=8140311">Library link</a>.</p>
</blockquote>
<p>This result not only justifies using natural cubic splines,
but also eliminates many of the unknown “tuning parameters” (the degree
of the spline basis, the number of knots, and their locations).
In fact, we only need to select one tuning parameter–the penalty term, which
can be done using any cross-validation “flavour” (although
in this setting leave-one-out CV is particularly appealing, as
we discussed in class).</p>
<p>The function <code>smooth.spline</code> in <code>R</code> computes a cubic smoothing spline
(natural cubic spline). Details on its arguments and different options
are available from its help page.</p>
<p>When applied to the <code>lidar</code> data with penalization
parameter equal to 0.2 (setting the argument <code>spar = 0.2</code>)
we obtain the following estimated regression function:</p>
<div class="sourceCode" id="cb89"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, spar <span class="op">=</span> <span class="fl">0.2</span>, cv <span class="op">=</span> <span class="cn">FALSE</span>,
    all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"magenta"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing1-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>This fit is clearly too wiggly and unsatisfactory. To obtain a smoother fit we increase the penalty term to 0.5:</p>
<div class="sourceCode" id="cb90"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, spar <span class="op">=</span> <span class="fl">0.5</span>, cv <span class="op">=</span> <span class="cn">FALSE</span>,
    all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing1.5-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>The larger the penalty parameter, the smoother the fit. Setting it to 0.8 yields:</p>
<div class="sourceCode" id="cb91"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, spar <span class="op">=</span> <span class="fl">0.8</span>, cv <span class="op">=</span> <span class="cn">FALSE</span>,
    all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing2-1.png" width="90%" style="display: block; margin: auto;"></div>
<p>It is easy to see that the larger the penalty coefficient the closer
the resulting natural cubic spline becomes to a linear function (why?).
For example, if we use <code><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline(spar=2)</a></code>:</p>
<div class="sourceCode" id="cb92"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, spar <span class="op">=</span> <span class="fl">2</span>, cv <span class="op">=</span> <span class="cn">FALSE</span>, all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"tomato3"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing3-1.png" width="90%" style="display: block; margin: auto;"></div>
</div>
<div id="selecting-an-optimal-penalty-parameter" class="section level2">
<h2>
<span class="header-section-number">7.6</span> Selecting an “optimal” penalty parameter<a class="anchor" aria-label="anchor" href="#selecting-an-optimal-penalty-parameter"><i class="fas fa-link"></i></a>
</h2>
<p>As discussed in class, an “optimal” natural cubic spline can be found using
cross-validation, and for these linear predictors, leave-one-out cross-validation
is particularly attractive (in terms of computational cost).
The function <code>smooth.spline</code> in <code>R</code> will compute (and use) an optimal value for the penalty term using
leave-one-out cross-validation when we set the argument <code>cv = TRUE</code>:</p>
<div class="sourceCode" id="cb93"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="va">tmp.cv</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, cv <span class="op">=</span> <span class="cn">TRUE</span>, all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="co"># tmp.cv$spar = 0.974</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp.cv</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp.cv</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">6</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing.cv1-1.png" width="90%" style="display: block; margin: auto;"></div>
<div id="sanity-check-always-a-good-idea" class="section level3">
<h3>
<span class="header-section-number">7.6.1</span> Sanity check (always a good idea)<a class="anchor" aria-label="anchor" href="#sanity-check-always-a-good-idea"><i class="fas fa-link"></i></a>
</h3>
<p>Note that the optimal value found for the regularization parameter (<code>spar</code>) is
also returned in the element
<code>$spar</code> of the object returned by <code>smooth.spline</code>. Just as a <strong>sanity check</strong>
we can now call <code>smooth.spline</code> with <code>cv = FALSE</code> and manually set
<code>spar</code> to this optimal value, and verify that we obtain the same fit:</p>
<div class="sourceCode" id="cb94"><pre class="downlit sourceCode r">
<code class="sourceCode R"><span class="fu"><a href="https://rdrr.io/r/graphics/plot.default.html">plot</a></span><span class="op">(</span><span class="va">logratio</span> <span class="op">~</span> <span class="va">range</span>, data <span class="op">=</span> <span class="va">lidar</span>, pch <span class="op">=</span> <span class="fl">19</span>, col <span class="op">=</span> <span class="st">"gray"</span>, cex <span class="op">=</span> <span class="fl">1.5</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp.cv</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp.cv</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">8</span>, col <span class="op">=</span> <span class="st">"blue"</span><span class="op">)</span>
<span class="va">tmp</span> <span class="op">&lt;-</span> <span class="fu"><a href="https://rdrr.io/r/stats/smooth.spline.html">smooth.spline</a></span><span class="op">(</span>x <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">range</span>, y <span class="op">=</span> <span class="va">lidar</span><span class="op">$</span><span class="va">logratio</span>, spar <span class="op">=</span> <span class="va">tmp.cv</span><span class="op">$</span><span class="va">spar</span>, cv <span class="op">=</span> <span class="cn">FALSE</span>,
    all.knots <span class="op">=</span> <span class="cn">TRUE</span><span class="op">)</span>
<span class="fu"><a href="https://rdrr.io/r/graphics/lines.html">lines</a></span><span class="op">(</span><span class="va">tmp</span><span class="op">$</span><span class="va">y</span> <span class="op">~</span> <span class="va">tmp</span><span class="op">$</span><span class="va">x</span>, lwd <span class="op">=</span> <span class="fl">3</span>, col <span class="op">=</span> <span class="st">"red"</span><span class="op">)</span></code></pre></div>
<div class="inline-figure"><img src="22-nonpar-splines-poly_files/figure-html/smoothing.cv2-1.png" width="90%" style="display: block; margin: auto;"></div>
</div>
</div>
<div id="the-problem-of-outliers-and-other-model-departures" class="section level2">
<h2>
<span class="header-section-number">7.7</span> The problem of outliers and other model departures<a class="anchor" aria-label="anchor" href="#the-problem-of-outliers-and-other-model-departures"><i class="fas fa-link"></i></a>
</h2>
<p>When the data may contain outliers and/or other atypical observations,
the estimation methods discussed above may be seriously affected, even
if there are only a few such aberrant data points in the training set
(possible outliers in the test / validation set are also a concern, but
we don’t have time to discuss it here). Some robust estimation
methods based on splines exist. See for example <span class="citation">(Tharmaratnam et al. <a href="references.html#ref-TharmaratnamClaeskens2010" role="doc-biblioref">2010</a>)</span>
and references therein. Software in <code>R</code> implementing this method is available
<a href="https://github.com/msalibian/PenalizedS">here</a>.</p>

</div>
</div>
  <div class="chapter-nav">
<div class="prev"><a href="lasso.html"><span class="header-section-number">6</span> LASSO</a></div>
<div class="next"><a href="kernel-regression-local-regression.html"><span class="header-section-number">8</span> Kernel regression / local regression</a></div>
</div></main><div class="col-md-3 col-lg-2 d-none d-md-block sidebar sidebar-chapter">
    <nav id="toc" data-toggle="toc" aria-label="On this page"><h2>On this page</h2>
      <ul class="nav navbar-nav">
<li><a class="nav-link" href="#non-parametric-regression"><span class="header-section-number">7</span> Non-parametric regression</a></li>
<li><a class="nav-link" href="#polynomial-regression"><span class="header-section-number">7.1</span> Polynomial regression</a></li>
<li><a class="nav-link" href="#a-more-stable-basis-splines"><span class="header-section-number">7.2</span> A more stable basis: splines</a></li>
<li><a class="nav-link" href="#higher-order-splines-quadratic-cubic-etc."><span class="header-section-number">7.3</span> Higher order splines (quadratic, cubic, etc.)</a></li>
<li><a class="nav-link" href="#how-many-knots-should-we-use"><span class="header-section-number">7.4</span> How many knots should we use?</a></li>
<li><a class="nav-link" href="#smoothing-splines"><span class="header-section-number">7.5</span> Smoothing splines</a></li>
<li>
<a class="nav-link" href="#selecting-an-optimal-penalty-parameter"><span class="header-section-number">7.6</span> Selecting an “optimal” penalty parameter</a><ul class="nav navbar-nav"><li><a class="nav-link" href="#sanity-check-always-a-good-idea"><span class="header-section-number">7.6.1</span> Sanity check (always a good idea)</a></li></ul>
</li>
<li><a class="nav-link" href="#the-problem-of-outliers-and-other-model-departures"><span class="header-section-number">7.7</span> The problem of outliers and other model departures</a></li>
</ul>

      <div class="book-extra">
        <ul class="list-unstyled">
<li><a id="book-source" href="https://github.com/ubc-stat/stat-406-worksheets/blob/main/22-nonpar-splines-poly.Rmd">View source <i class="fab fa-github"></i></a></li>
          <li><a id="book-edit" href="https://github.com/ubc-stat/stat-406-worksheets/edit/main/22-nonpar-splines-poly.Rmd">Edit this page <i class="fab fa-github"></i></a></li>
        </ul>
</div>
    </nav>
</div>

</div>
</div> <!-- .container -->

<footer class="bg-primary text-light mt-5"><div class="container"><div class="row">

  <div class="col-12 col-md-6 mt-3">
    <p>"<strong>UBC Stat 406 Worksheets</strong>" was written by Daniel J. McDonald and Matías Salibán-Barrera. It was last built on 2021-08-18.</p>
  </div>

  <div class="col-12 col-md-6 mt-3">
    <p>This book was built by the <a class="text-light" href="https://bookdown.org">bookdown</a> R package.</p>
  </div>

</div></div>
</footer><!-- dynamically load mathjax for compatibility with self-contained --><script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "true";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script><script type="text/x-mathjax-config">const popovers = document.querySelectorAll('a.footnote-ref[data-toggle="popover"]');
for (let popover of popovers) {
  const div = document.createElement('div');
  div.setAttribute('style', 'position: absolute; top: 0, left:0; width:0, height:0, overflow: hidden; visibility: hidden;');
  div.innerHTML = popover.getAttribute('data-content');

  var has_math = div.querySelector("span.math");
  if (has_math) {
    document.body.appendChild(div);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, div]);
    MathJax.Hub.Queue(function() {
      popover.setAttribute('data-content', div.innerHTML);
      document.body.removeChild(div);
    })
  }
}
</script>
</body>
</html>
